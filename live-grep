#!/bin/bash

set -e

# Configuration
VERSION="0.1.0"
PREVIEW_CONTEXT=2
TEMP_DIR=""
PIPE_FILE=""
CURRENT_QUERY=""
LAST_PID=""

# Check required dependencies
check_dependencies() {
    local missing=()
    for cmd in fzf rg bat mkfifo; do
        if ! command -v "$cmd" &> /dev/null; then
            missing+=("$cmd")
        fi
    done

    if [ ${#missing[@]} -ne 0 ]; then
        echo "Error: Required commands not found: ${missing[*]}" >&2
        echo "Please install missing dependencies and try again." >&2
        exit 1
    fi
}

# Setup temporary directory and IPC
setup_temp() {
    TEMP_DIR=$(mktemp -d)
    PIPE_FILE="${TEMP_DIR}/results"
    # Create a pipe for inter-process communication
    mkfifo "$PIPE_FILE"

    # Create preview script
    cat > "${TEMP_DIR}/preview.sh" << 'EOF'
#!/bin/bash
IFS=: read -r file line rest <<< "$1"
if [ -z "$file" ] || [ -z "$line" ]; then
    exit 1
fi

line=$(echo "$line" | tr -d '[:space:]')
context=${2:-2}

if [ "$line" -gt "$context" ]; then
    start=$((line - context))
else
    start=1
fi
end=$((line + context))

exec bat --style=numbers \
    --color=always \
    --highlight-line "$line" \
    --line-range "$start:$end" \
    "$file"
EOF
    chmod +x "${TEMP_DIR}/preview.sh"

    # Create cleanup script
    cat > "${TEMP_DIR}/cleanup.sh" << 'EOF'
#!/bin/bash
kill_process_group() {
    local pid=$1
    if [ -n "$pid" ]; then
        pkill -TERM -P "$pid" 2>/dev/null || true
        kill -TERM "$pid" 2>/dev/null || true
    fi
}

if [ -f "$1" ]; then
    pid=$(cat "$1" 2>/dev/null)
    kill_process_group "$pid"
fi
EOF
    chmod +x "${TEMP_DIR}/cleanup.sh"

    # Set cleanup trap
    trap 'cleanup' EXIT INT TERM
}

# Cleanup resources
cleanup() {
    # Kill running processes
    if [ -f "${TEMP_DIR}/current_search.pid" ]; then
        "${TEMP_DIR}/cleanup.sh" "${TEMP_DIR}/current_search.pid"
    fi

    # Remove temporary directory
    if [ -n "$TEMP_DIR" ] && [ -d "$TEMP_DIR" ]; then
        rm -rf "$TEMP_DIR"
    fi
}

# Display help message
show_help() {
    cat << EOF
live-grep $VERSION
Interactive command-line tool for real-time file content search

Usage: live-grep [options] [paths...]

Options:
    -p, --pattern PATTERN    File pattern to search (e.g., "*.rs")
    -d, --depth DEPTH       Maximum search depth
    -c, --context LINES     Number of context lines in preview (default: 2)
    -e, --exclude PATTERN   Exclude pattern
    -h, --help             Show this help message
    -v, --version          Show version

Examples:
    live-grep                          # Search in current directory
    live-grep -p "*.rs" src/           # Search Rust files in src/
    live-grep -c 5                     # Show 5 context lines
    live-grep -e "node_modules/"       # Exclude node_modules directory
EOF
}

# Display version
show_version() {
    echo "live-grep version $VERSION"
}

# Execute search
execute_search() {
    local query=$1
    shift
    local pid_file="${TEMP_DIR}/current_search.pid"

    # Skip empty query
    if [ -z "$query" ]; then
        echo ""
        return
    fi

    # Kill previous search
    if [ -f "$pid_file" ]; then
        "${TEMP_DIR}/cleanup.sh" "$pid_file"
    fi

    # Start new search
    "$@" & echo $! > "$pid_file"
}

# Main process
main() {
    local pattern=""
    local depth=""
    local exclude=""
    local paths=()

    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            -p|--pattern)
                pattern=$2
                shift 2
                ;;
            -d|--depth)
                depth=$2
                shift 2
                ;;
            -c|--context)
                PREVIEW_CONTEXT=$2
                shift 2
                ;;
            -e|--exclude)
                exclude=$2
                shift 2
                ;;
            *)
                paths+=("$1")
                shift
                ;;
        esac
    done

    # Check dependencies
    check_dependencies

    # Setup temporary directory and IPC
    setup_temp

    # Set search paths
    [ ${#paths[@]} -eq 0 ] && paths=(.)

    # Build ripgrep options
    local rg_opts=(
        --line-number
        --column
        --color always
        --smart-case
    )
    [ -n "$pattern" ] && rg_opts+=(--type-add "custom:$pattern" --type custom)
    [ -n "$depth" ] && rg_opts+=(--max-depth "$depth")
    [ -n "$exclude" ] && rg_opts+=(--glob "!$exclude")

    # Build search command
    search_cmd="rg ${rg_opts[*]}"

    # Execute fzf and process results
    echo "" | \
    fzf \
        --delimiter=: \
        --preview "${TEMP_DIR}/preview.sh {} $PREVIEW_CONTEXT" \
        --preview-window "right:50%:+{2}-$PREVIEW_CONTEXT" \
        --bind "change:reload($search_cmd {q} ${paths[*]} || true)" \
        --ansi \
        --disabled \
        --query "" \
        --height "80%" \
        --info inline \
        --border \
        --exit-0 | \
    cut -d: -f1
}

main "$@"